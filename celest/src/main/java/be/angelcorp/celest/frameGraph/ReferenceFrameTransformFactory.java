/**
 * Copyright (C) 2009-2012 simon <simon@angelcorp.be>
 *
 * Licensed under the Non-Profit Open Software License version 3.0
 * (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.opensource.org/licenses/NOSL3.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package be.angelcorp.celest.frameGraph;

import be.angelcorp.celest.time.Epoch;

/**
 * Factory construct capable of creating a ReferenceFrameTransform between two different ReferenceFrames.
 *
 * @author Simon Billemont
 * @tparam F0 Transform from this ReferenceFrame.
 * @tparam F1 Transform to this ReferenceFrame.
 */
public interface ReferenceFrameTransformFactory<F0 extends ReferenceSystem, F1 extends ReferenceSystem> {

    /**
     * Apply another ReferenceFrameTransformFactory on top of this transformFactory, so that the
     * resulting transformationFactory produces transforms which start at the same frame as the staring
     * frame of this factory, and results in the final frame of the given factory.
     *
     * @param other ReferenceFrameTransformFactory to add to this factory.
     * @return A ReferenceFrameTransformFactory from F0 to F2.
     */
    public <F2 extends ReferenceSystem> ReferenceFrameTransformFactory<F0, F2> add(ReferenceFrameTransformFactory<F1, F2> other);

    /**
     * Rough estimate of the number of operations required to <b>create and apply</b> a ReferenceFrame.
     * <p/>
     * <p>
     * This method is used to find optimal (performance wide) transfers between different frameGraph when multiple paths
     * are possible. It is important to make this method <b>fast</b>. Possible checks include, checking the existence
     * of cache variable, if all required data files have been loaded, ...
     * </p>
     *
     * @param epoch Epoch at which to construct and apply a potential transform.
     * @return Rough cost estimate of creating/applying this a ReferenceFrameTransform.
     */
    public double cost(Epoch epoch);

    /**
     * Get a new transform that, when applied, transforms from F0 to F1.
     *
     * @param epoch Epoch at which the ReferenceFrameTransform must be valid.
     * @return An transformation between the specified ReferenceFrames.
     */
    public ReferenceFrameTransform<F0, F1> transform(Epoch epoch);

    /**
     * Get a new transformFactory that produces transforms that undo the effects of the transforms
     * generated by this transformFactory. This means:
     * <p/>
     * <pre>
     * Epoch t;
     * f = this.getTransform(t);
     * g = this.inverse().getTransform(t);
     * v = g.transform(f.transform(v))
     * </pre>
     *
     * @return An inverse transformation of this ReferenceFrameTransform
     */
    public ReferenceFrameTransformFactory<F1, F0> inverse();

    /**
     * Instance of the reference base frame from which the transformation takes place.
     */
    public F0 fromFrame();

    /**
     * Instance of the reference base frame to which the transformation transforms.
     */
    public F1 toFrame();

}